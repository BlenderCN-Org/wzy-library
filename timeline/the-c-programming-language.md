##《C 程序设计语言》读书笔记

书上的练习，只做了一部分，而且有的代码有 error, 
[C Programming Language 2nd 习题代码](code/README.md)</br>
以下是我的读书笔记：

##第一章 入门

###printf 函数

printf 函数永远不会自动换行。

printf 函数转换说明：

- `%d`: 十进制数；
- `%o`: 八进制数；
- `%x`: 十六进制数；
- `%c`: 字符；
- `%s`: 字符串；
- `%%`: 百分号（%）本身；
- `%6.2f`: 按照浮点数打印，至少 6 个字符宽，小数点后有两位小数。

C 语言中一个通用规则：在允许使用某种类型变量值的任何场合，都可以使用该类型的更复杂的表达式。

###for 语句

for 语句比较适合初始化和增加步长都是单条语句并且逻辑相关的情形，因为它将循环控制语句集中放在一起，且比 while 语句更紧凑。

###符号常量

`#define` 指令可以把符号名（或称为符号常量）定义一个特定的字符串:

	#define 名字 替换文本

符号常量名通常用大写字母拼写，这样可以很容易与用小写字母拼写的变量名相区别。
注意: `#define` 指令行的末尾没有分号。

###文件复制

EOF 是在文件 `stdio.h` 中定义的特殊值（其实是整型数），一般 `#define` 指令把 EOF 的值定义为 -1.

###字符计数

有一点值得强调：while 语句与 for 语句的优点之一就是在执行循环体之前就对条件进行测试，如果条件不满足，则不执行循环体，这就可能出现循环体一次都不执行的情况。

###行计数

C 语言将单等于号 `=` 作为赋值运算符，使用双等于号 `==` 表示相等的逻辑关系。所以这里需注意，在表示 “等于” 逻辑关系的时候，应使用 `==`。

###单词计数

在兼有值与赋值两种功能的表达式中，赋值结合次序是由右至左。比如:

	nl = nw = nc = 0; 
	\\等同于:
	nl = (nw = (nc = 0));


###数组

数字的字符表示属性，例如测试语句:

	if (c >= '0' && c <= '9')

用于判断 c 中的字符是否为数字。
long 类型的打印说明符: `%lu`.

###参数--传值调用

C 语言中，所有函数参数都是 “通过值” 传递的，传递给被调用函数的参数值存放在临时变量中，而不是存放在原来的变量中，也就是说，被调用函数不能直接修改主调函数中变量的值，而只能修改其私有的临时副本的值。
必要时，如果想让函数能够修改主调函数中的变量，则需要向被调用函数提供待设置值的变量的地址（从技术角度来说，地址就是指向变量的指针），而被调用函数则需要将对应的参数声明为指针类型，并通过它间接访问变量。

###字符数组

`printf` 函数中的格式规范 `%s` 规定，对应的参数必须是以 `\0` (空字符，其值为 0) 标记结束的字符串。

###外部变量与作用域

函数中的每个局部变量只在函数被调用时存在，在函数执行完毕退出时消失，所以 “局部变量” 也称为 “自动变量”。

外部变量必须定义在所有函数之外，且只能定义一次，定义后编译程序将为它分配存储单元。在每个需要访问外部变量的函数中，必须声明相应的外部变量，并说明其类型。声明时可以用 extern 语句显式声明，也可以通过上下文隐式声明。

如果在源文件中，外部变量的定义出现在使用它的函数之前，那么在那个函数中就没有必要使用 extern 声明。通常的做法是，所有外部变量的定义都放在源文件的开始处。

定义（define）表示创建变量或分配存储单元，而声明（declaration）指的是说明变量的性质，但并不分配存储单元。

将其所操纵的变量名直接写入函数，会使函数失去通用性。

##第二章 类型、运算符与表达式

###变量名

在变量名的命名中，下划线 `_` 被看做是字母，通常用于命名较长的变量名，以提高可读性。由于例程的名字通常以下划线开头，因此变量不要以下划线开头。

###数据类型及长度

各编译器可以根据硬件特性自主选择合适的类型长度，但要遵循下列限制: `short` 与 `int` 类型至少为 16 位，而 `long` 类型至少为 32 位，并且 `short` 类型不得长于 `int` 类型，而 int 类型不得长于 `long` 类型。

`int` 通常代表特定机器中整数的自然长度。`short` 类型通常为 16 位，`long` 类型通常为 32 位，`int` 类型可以为 16 位或 32 位。

类型限定符 `signed` 与 `unsigned` 可用于限定 `char` 类型或任何整型。`nsigned` 类型的数总是正值或 0，并遵守算术模 2^n 定律，其中 n 是该类型占用的位数。例如，如果 `char` 对象占用 8 位，那么 `unsigned char` 类型变量的取值范围 0~255，而 `signed char` 类型变量的取值范围则为 -128~127（在采用对二的补码的机器上）。不带限定符的 `char` 类型对象是否带符号取决于具体机器，但可打印字符总是正值。

`long double` 类型表示高精度的浮点数，同整型一样，浮点型的长度也取决于具体的实现。`float`, `double` 与 `long double` 类型可以表示相同的长度，也可以表示两种或三种不同的长度。

有关数据类型长度定义的符号常量以及其他与机器和编译器有关的属性可以查看标准头文件 `<limits.h>` 与 `<float.h>`.

###常量

ANSI C 语言中的全部转义字符序列：

- `\a`（响铃符）
- `\b`（回退符）
- `\f`（换页符）
- `\n`（换行符）
- `\r`（回车符）
- `\t`（横向制表符）
- `\v`（纵向制表符）
- `\\`（反斜杠）
- `\?`（问号）
- `\'`（单引号）
- `\"`（双引号）
- `\ooo`（八进制数）
- `\xhh`（十六进制数）


字符常量 `\0` 表示值为 0 的字符，也就是空字符（null）。通常用 `\0` 的形式代替 0，以强调某些表达式的字符属性，但其数字值为 0。

字符常量与仅包含一个字符的字符串之间的区别：'x' 与 "x" 是不同的:

- 'x' 是一个整数，其值是字母 x 在机器字符集中对应的数值（内部表示值）；
- "x" 是一个包含一个字符（即字母 x）以及一个结束符 '\0‘ 的字符数组。

###声明
任何变量的声明都可以使用 `const` 限定符限定。该限定符指定变量的值不能被修改。对数组而言，`const` 限定符指定数组所有元素的值都不能被修改。

###类型转换
标准头文件 `<ctype.h>` 定义了一组与字符集无关的测试和转换函数。

C 语言没有指定 `char` 类型的变量是有符号变量（`signed`）还是无符号变量（`unsigned`）。当把一个 `char` 类型的值转换为 `int` 类型的值的时候，其结果是否为负整数取决于机器结构。在某些机器中，如果 `char` 类型值的最左一位为 1，则转换为负整数（进行 “符号扩展”）。而在另一些机器中，把 `char` 类型值转换为 `int` 类型时，在 `char` 类型值的左边添加 0，其转换结果总是正值。

C 语言的定义保证了机器的标准打印字符集中的字符不会是负值，也就是表达式中的字符总是正值，但是，存储在字符变量中的位模式在某些机器中可能是负的。所以为了保证程序的可移植性，如果要在 `char` 类型的变量中存储非字符数据，最好指定 `signed` 或 `unsigned` 限定符。

C 语言中，如果没有 `unsigned` 类型的操作数，非正式的转换规则：

- 如果其中一个操作数的类型为 `long double`, 则将另一个操作数转换为 `long double` 类型；
- 如果其中一个操作数的类型为 `double`，则将另一个操作数转换为 `double` 类型；
- 如果其中一个操作数的类型为 `float`，则将另一个操作数转换为 `float` 类型；
- 将 `char` 与 `short` 类型的操作数转换为 `int` 类型；
- 如果其中一个操作数的类型为 `long`，则将另一个操作数也转换为 `long` 类型。

表达式中 `float` 类型的操作数不会自动转换为 `double` 类型，数学函数（在标准头文件 `<math.h>` 中定义的函数）使用双精度类型的变量。使用 `float` 类型主要是为了在使用较大的数组时节省存储空间，有时也为了节省机器执行时间（双精度算术运算特别费时）。

在任何表达式中都可以使用一个成为强制类型转换的一元运算符强制进行显式类型转换。

库函数 `sqrt` 的参数为 `double` 类型，所以可以使用强制类型转换：`sqrt ((double) n)`，在把 n 传递给函数 sqrt 之前先将其转换为 `double` 类型。注意，强制类型转换符只是生成一个指定类型的 n 值，n 本身的值并没有改变。

通常情况下，参数是通过函数原型声明的。这样，当函数被调用时，声明将对参数进行自动强制转换。

###自增运算符与自减运算符

	s[ j++ ] = s [ i ]; 
	\\等价于:
	s[ j ] = s[ i ];
	j++;

即先拷贝数组中下标为 j 的位置，随后才将 j 的值增加 1。

###按位运算符

C 语言提供了 6 个位操作运算符。这些运算符只能作用于整型操作数，即只能作用于带符号或无符号 `char`, `short`, `int`, `long` 类型:

- `&` 按位与（AND）
- `|` 按位或（OR）
- `^` 按位异或（XOR）
- `<<` 左移
- `>>` 右移
- `~` 按位求反（一元运算符）

###赋值运算符与表达式

如果 expr1 和 expr2 是表达式，那么

	expr1 op= expr2
	\\等价于:
	expr1 = (expr1) op (expr2)

赋值表达式的类型是它的左操作数的类型，其值是赋值操作完成后的值。

##第三章 控制流

###switch 语句

在 switch 语句中，`case` 的作用只是一个标号。

##第四章 函数与程序结构

###外部变量

由于 C 语言不允许在一个函数中定义其它函数，因此函数本身是 “外部的”。默认情况下，外部变量与函数具有下列性质：通过同一个名字对外部变量的所有引用（即使这种引用来自于单独编译的不同函数）实际上都是引用同一个对象（标准中把这一性质称为外部链接）。

外部变量的初始化只能出现在其定义中。

外部的 `static` 声明通常多用于变量，当然，它也可用于声明函数。通常情况下，函数名字是全局可访问的，对整个程序的各个部分而言都可见。但是，如果把函数声明为 `static` 类型，则该函数名除了对该函数声明所在的文件可见外，其它文件都无法访问。

`static` 类型的内部变量是一种只能在某个特定函数中使用但一直占据存储空间的变量。

###寄存器变量

`register` 声明告诉编译器，它所声明的变量在程序中使用频率较高。其思想是，将 `register` 变量放在机器的寄存器中，这样可以使程序更小、执行速度更快。但编译器可以忽略此项。

`register` 声明只适用于自动变量以及函数的形式参数。

无论寄存器变量实际上是不是存放在寄存器中，它的地址都是不能访问的。在不同的机器中，对寄存器变量的数目和类型的具体限制也是不同的。

###程序块结构

在一个好的程序设计风格中，应该避免出现变量名隐藏外部作用域中相同名字的情况，否则，很可能引起混乱和错误。

###初始化

对于外部变量与静态变量，初始化表达式必须是常量表达式，且只初始化一次（从概念上讲是在程序开始执行前进行初始化）。对于自动变量与寄存器变量，则在每次进入函数或程序块时都将被初始化。

如果初始化表达式的个数比数组元素数少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为 0。

##第五章 指针与数组

ANSI C 使用类型 `void*`（指向 void 的指针）代替 `char*` 作为通用指针的类型。

###指针与地址

一元运算符 `&` 可用于取一个对象的地址（取对象的地址）。

一元运算符 `*` 是间接寻址或间接引用运算符。当它作用于指针时，将访问指针所指向的对象（取指针的对象）。

指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型（一个例外情况是指向 `void` 类型的指针可以存放指向任何类型的指针，但它不能间接引用自身）。

语句 `(*ip)++` 中的圆括号是必需的，否则，该表达式将对 ip 进行加 1 运算，而不是对 ip 指向的对象进行加 1 运算，这是因为，类似于 `*` 和 `++` 这样的一元运算符遵循从右至左的结合顺序。

###指针与数组

一个通过数组和下标实现的表达式可等价地通过指针和偏移量实现。

###地址算术运算

C 语言保证，0 永远不是有效的数据地址，因此，返回值 0 可用来表示发生了异常事件。

指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 进行比较。程序中经常用符号常量 NULL 代替常量 0，这样便于更清晰地说明常量 0 是指针的一个特殊值。符号常量 NULL 定义在标准头文件 `<stddef.h>` 中。

p+n 表示指针 p 当前指向的对象之后第 n 个对象的地址。无论指针 p 指向的对象是何种类型，上述结论都成立。在计算 p+n 时，n 将根据 p 指向的对象的长度按比例缩放，而 p 指向的对象的长度则取决于 p 的声明。

指针的算术运算具有一致性：如果处理的数据类型是比字符型占据更多存储空间的浮点类型，并且 p 是一个指向浮点类型的指针，那么在执行 p++ 后，p 将指向下一个浮点数的地址。所有的指针运算都会自动考虑它所指向的对象的长度。

以下两个表达式：

	*p++ = val;	\\将 val 压入栈
	val = *--p; \\将栈顶元素弹出到 val 中

是进栈和出栈的标准用法。

###多维数组

声明:

	f ( int ( *daytab ) [13] ) { ... }

表明参数是一个指针，它指向具有 13 个整型元素的一维数组。因为方括号 `[ ]` 的优先级高于 `*` 的优先级，所以上述声明中必须使用圆括号。如果去掉括号，则声明变成：

	int *daytab [ 13 ]

这相当于声明了一个数组，该数组有 13 个元素，其中每个元素都是一个指向整型对象的指针。

###指针与多维数组

指针数组的一个重要优点在于，数组的每一行长度可以不同。

###命令行参数

调用主函数 `main` 时，它带有两个参数。

第一个参数（习惯上称为 `argc`，用于参数计数）的值表示运行程序时命令行中参数的数目；
第二个参数（称为 `argv`，用于参数向量）是一个指向字符串数组的指针，其中每个字符串对应一个参数。
通常用多级指针处理这些字符。

按照 C 语言的规定，argv[0] 的值是启动该程序的程序名，因此 argc 的值至少为 1。如果 argc 的值为 1，则说明程序名后面没有命令行参数。另外，ANSI 标准要求 argv[argc] 的值必须为一个空指针（\0）。

参数为指针类型调用函数时，函数前面不需要加上取地址运算符 `&`, 同样的原因，数组名前面也不需要 & 运算符。

由于任何类型的指针都可以转换为 `void*` 类型，并且在将它转换回原来的类型时不会丢失信息，所以，调用函数时可以将参数强制转换为 `void*` 类型。比较函数的参数也要执行这种类型的转换。这种转换通常不会影响到数据的实际表示，但要确保编译器不会报错。

对比 `comp` 的声明：

	int ( *comp ) ( void*, void* )

它表明 `comp` 是一个指向函数的指针，该函数具有两个 `void*` 类型的参数，其返回值类型为 `int`.

如果没有括号：

	int *comp ( void*, void* )

则表明 `comp` 是一个函数，该函数返回一个指向 `int` 类型的指针（因为指针符号 `*`  是一个前缀运算符，其优先级低于 `( )`，所以，声明中必须使用圆括号以保证正确的结合顺序）。

###复杂声明

对声明符的语法简化：

	dcl:    optional *'s direct-dcl
	direct-dcl name
	               (dcl)
	               direct-dcl ()
	               direct-dcl [optional size]

简而言之，声明符 `dcl` 就是前面可能带有多个 `*` 的 `direct-dcl`. `direct-dcl` 可以是 `name`, 由一对圆括号括起来的 `dcl`, 后面跟有一对圆括号的 `direct-dcl`, 后面跟有用方括号括起来的表示可选长度的 `direct-dcl`.

##第六章 结构

###类型定义

C 语言提供 `typedef` 功能用来建立新的数据类型名。

从任何意义上讲，`typedef` 声明并没有创建一个新类型，它只是为某个已存在的类型增加了一个新的名称而已。`typedef` 声明也没有增加任何新的语义：通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性。实际上，`typedef` 类似于 `#define` 语句，但由于 `typedef` 是由编译器解释的，因此它的文本替换功能要超过预处理器的能力。

使用 `typedef` 有两种重要原因：

- `typedef` 可以使程序参数化，以提高程序的可移植性。如果 `typedef` 声明的数据类型同机器有关，那么，当程序移植到其它机器上时，只需要改变 `typedef` 类型定义就可以了。一个经常用到的情况是，对于不同大小的整型，都使用通过 `typedef` 定义的类型名，然后分别为各个不同的宿主机选择一组合适的 `short`, `int` 和 `long` 类型大小即可。
- `typedef` 可以为程序提供更好的说明性。

###位字段

位字段（bit-field），或简称字段，是 “字” 中相邻的集合。“字”（word）是单个的存储单元，与具体的实现有关。

##第八章 Unix 系统接口

###文件描述符

可以通过 `<` 和 `>` 重定向程序的 I/O：

prog < 输入文件名 > 输出文件名

除了默认的标准输入、标准输出和标准错误文件外，其它文件都必须在读或写之前显示地打开。系统调用 `open` 和 `creat` 用于实现该功能。

`open` 与 `fopen` 相似，不同的是，`open` 返回一个文件描述符，它仅仅是一个 `int` 类型的数值。而 `fopen` 返回一个文件指针。如果发生错误，`open` 将返回 -1.

如果 `creat` 成功创建了文件，它将返回一个文件描述符，否则返回 -1。如果此文件已经存在，`creat` 将把该文件的长度截断为 0，从而丢弃原先已有的内容。使用 `creat` 创建一个已存在的文件不会导致错误。

函数 `unlink ( char *name )` 将文件 name 从文件系统中删除，对应于标准库函数 `remove`.