##《C Primer Plus》读书笔记

###第 1 章 概览

使用 C 语言的 7 个步骤

1. 定义程序目标；
2. 设计程序；
3. 编写代码；
4. 编译；
5. 运行程序；
6. 测试和调试程序；
7. 维护和修改程序。


###第 2 章 C 语言概述

####include 指示和头文件</br>
这是程序的第一行，该语句的作用相当于您再文件中该行所在的文件键入了文件 `stdio.h` 的完整内容。</br>
`#include` 语句是 C 预处理器指令（preprocessor directive）的一个例子，通常，C 编译器在编译前要对源代码做一些准备工作，称为预处理（preprocessing）。
`stdio.h` 文件作为所有 C 编译包得一部分提供，它包含了有关输入和输出函数（例如 `printf（）`）的信息以供编译器使用。这个名字代表标准输入输出头文件（standard input/output header）。在 C 中，称出现在文件顶部的信息集合为头（header）。

####main（）函数
您可以对您所用的其他函数任意命名，但是 `main（）` 函数必须是开始的函数。

####注释
`/* */` 可以多行，`//` 的注释必须被限制在一行内。

####花括号，程序体和代码块
所有的 C 函数都使用花括号来表示函数的开始与结束，而且仅有花括号 { } 能起到这种作用，小括号（）和中括号 [ ] 都不行。

####声明
`int num` 为声明语句（declaration statement）。`num` 是一个标识符（identifier），也就是您为一个变量、函数或其他实体所选的名字。
在 C 语言中，所有变量都必须在使用之前定义。这就意味着您必须提供程序中要用到的所有变量名的列表，并且指出每个变量的数据类型。传统上，C 语言要求必须在一个代码块的开始处声明变量，在这之前不允许任何其他语句。

####数据类型
C 语言可以处理多个数据种类（或类型），例如整数、字符和浮点数。把一个变量声明为整数类型或字符类型是计算机正确地存储、获取和解释该数据的基本前提。

####名字的选择
可供变量名使用的字符有小写字母、大写字符、数字和下划线（ _ ）。第一个字符必须是字母或者下划线。
操作系统和 C 库通常使用以一个或两个下划线开始的名字（例如 _kcab），因此自己给变量命名时最好避免这种用法。

####换行符
`\n` 代表一个换行符（newline character）。
换行符是转义字符（Escape Sequence）的一个例子。转义字符通常用于代表难于表达的或是无法键入的字符。其他的例子比如 `\t` 代表 Tab 键，`\b` 代表退格键，每个转义字符都用斜线字符 `\` 开始。

####%d
`%` 告诉程序把一个变量在这个位置输出，`d` 告诉程序将输出一个十进制（以 10 为基数）整数变量。

####printf（）
`printf（）` 函数允许多种输出变量格式，包括十六进制（以 16 为基数）整数和带小数点的数。实际上，`printf（）` 中的 `f` 暗示着这是一种格式化（formating）的输出函数。
一个简单的标准 C 程序应使用如下格式：

	#include <stdio.h>
	int main (void)
	{
    	statements
    	return 0;
	}

编译器会把用关键字作为变量名当做一个语法错误捕获，还有一些不该用的其他字符，称为保留标识符（reserved identifier），它们是合法的名字，但 C 语言已使用它们或者保留使用它们的权利，所以如果使用保留标识符表示其他意思就可能引起问题。保留标识符包括那些以下划线字符开始的标识符和标准库函数的名字，例如 `printf（）`.

###第 3 章 数据和 C

####浮点数
浮点变量（float）类型可以处理带有小数点的数字，在 `printf（）` 代码中可以使用 `%f` 说明符来处理浮点值，对 `%f` 说明符使用 `.2` 修饰词可以精确控制输出格式，使浮点数显示到小数点后两位。

####C 的数据关键字
原来的 K&R 关键字：`int`, `long`, `short`, `unsigned`, `char`, `float`, `double`.
C90 关键字：`signed`, `void`.
C99 关键字：`_Bool`, `_Complex`, `_Imaginary`.

####% 说明符的使用
C 允许使用三种数制书写和显示数字，`%d`代表十进制，`%o`代表八进制，`%x`代表十六进制整数。如果想显示 C 语言前缀，可以使用说明符 `%#o`，`%#x` 和 `%#X` 分别生成 0，0x 和 0X 前缀。
打印类型不正确不会显示近似的值（比如使用`%d`显示 float 值），而是显示垃圾值。

####非打印字符
C 提供了三种非打印字符的方法：

1. 使用 ASCII 码；
2. 使用转义序列（Escape Sequence）；
3. 使用十六进制形式表示字符常量。


####_Bool 类型
_Bool 类型由 C99 引入，用于表示布尔值，即逻辑值 true（真）与 false（假），_Bool 类型实际上也是一种整数类型，原则上它仅仅需要 1 位来进行存储。

####可移植的类型：inttypes.h

`inttypes.h` 头文件提供了可选名字集合，以确切描述有关整数类型信息。

####浮点数
C 可以通过 `f` 或 `F` 后缀使编译器把浮点常量当作 float 类型，比如 2.3f 和 9.11E9F。`l` 或 `L` 后缀使一个数字成为 long double 类型，比如 4.32e4L（建议使用 L 后缀，因为字符 l 容易和数字 1 混淆）。没有后缀的浮点常量为 double 类型。

####打印浮点值
`printf（）` 函数使用 `%f` 格式说明符打印十进制记数法的 float 和 double 数字，用 `%e` 打印指数记数法的数字，系统支持 C99 的十六进制格式浮点数，可以使用 `a` 或 `A` 代替 `e` 或 `E`。打印 long double 类型需要 `%Lf`，`%Le` 和 `%La` 说明符。

注意 float 和 double 类型的输出都使用 `%f`，`%e` 或 `%a` 说明符。这是由于他们向那些未在原型中显式说明参数类型的函数（如 printf（））传递参数时，C 自动将 float 类型的参数转换为 double 类型。

####浮点值的上溢和下溢
上溢（overflow）发生在当计算结果是一个大到不能表达的数，C 会赋予一个代表无穷大的特殊值，比如 inf 或 infinity。
下溢（underflow）是一个数字很小，但指数已经达到了最小值，所以计算机只好将尾数部分的位进行右移，空出首位二进制位并丢弃最后一位二进制的过程，C 将损失了类型精度的浮点值称为低于正常的（subnormal）。
特殊的浮点值 NaN（Not-a-Number）。

####复数和虚数类型
有三种复数类型，分别是 `float_Complex`，`double_Complex` 和 `long double_Complex`。`float_Complex` 变量包含两个 `float` 值，一个表示复数的实部，另一个表示复数的虚部。与之类似，有三种虚数类型，分别是 `float_Imaginary`，`double_Imaginary` 和 `long double_Imaginary`。
如果包含了 `complex.h` 头文件，则可以用 `complex` 代替 ` _Complex`，用 `imaginary` 代替 `_Imaginary`，用符号 I 表示 -1 的平方根。

###第 4 章 字符串和格式化输入/输出

####空字符
C 把字符串存储在 `char` 数组中，字符串中的字符存放在相邻的存在存储单元中，每个字符占用一个单元，数组中最后一个位置显示字符 \0，即空字符（null character），C 用它来标记字符串的结束。空字符不是数字 0；它是非打印字符，其 ASCII 码的值为（或者等同于）0. C 的字符串存储时通常以这个空字符结束。该字符的存在意味着数组的单元必须至少比要存储的字符数多 1.

####scanf
（注意）`scanf()` 开始读取输入以后，会在遇到的第一个空白字符空格（blank）、制表符（tab）或换行符（newline）处停止读取。

####预处理
预处理器允许定义常量，一般形式为：

	#define NAME value

这种方法成为编译时代入法（compile-time substitution），这样定义的常量被称为明显常量（manifest constant）。
`#define` 语句也可以用于定义字符和字符串常量，前者用单引号，后者用双引号。

####系统定义的明显常量
C 头文件 `limits.h` 和 `float.h` 分别提供有关整数类型和浮点类型的大小限制的详细信息。每个文件都定义了一系列应用于您的实现的明显常量。

####printf
请求 `printf（）` 打印变量的指令取决于变量的类型，例如在打印整数时使用 `%d` 符号，打印字符时使用 `%c` 符号，这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。

	printf (Control-string, item1, item2, ...);

控制字符串（control-string）是一个描述项目如何打印的字符串，控制字符串包含了两种形式截然不同的信息：实际要打印的字符和转换说明。

####printf（）的转换说明修饰符
可以在 `%` 和定义转换字符之间通过插入修饰符对基本的转换说明加以修改。

一些常用的 `printf（）` 修饰符：

- `digit（s）`：字段宽度的最小值，如果该字段不能容纳要打印的数或者字符串，系统就会使用更宽的字段；
- `.digit（s）`：精度；
- `-`：项目是左对齐；
- `+`：有符号的值若为正，则显示带加号的符号；若为负，则带减号的符号；
- （空格）：有符号的值若为正，则显示时带前导空格（但是不显示符号）；若为负，则带减号符号。+ 标识会覆盖空格标志；
- `#`：使用转换说明的可选形式；

####参数传递
参数传递的机制随实现不同而不同，如果 `printf（）` 语句在其他地方出现不匹配错误，即使正确的说明符也会产生错误的结果。

####printf（）的返回值
`printf（）` 函数返回值等于它所打印的字符数目。

####打印较长的字符串
有三种方法可以分割一个字符串：

1. 使用多个 `printf（）` 语句；
2. 用反斜线符号 `\` 和回车键的组合来结束第一行。这就使得屏幕上的文本另起一行，并且在字符串中不会包含换行字符。其效果就是在下一行继续该字符串。不过，下一行必须像代码那样从行的最左边开始。如果缩进了该行，那么缩进的空格会变成字符串的一部分。
3. 采用字符串连接，在一个用双引号引起来的字符串后面跟有另一个用双引号引起来的字符串，而且二者之间仅用空白字符分隔，C 会把该组合当作一个字符串来处理。

####scanf（）
如果使用 `scanf（）` 来读取基本变量类型的值，请在变量名之前加上一个 `&`；
如果使用 `scanf（）` 把一个字符串读进一个字符数组中，不要使用 `&`。

ANSI C 中常用的 `scanf（）` 转换说明符：

- `%c`：把输入解释成一个字符；
- `%d`：把输入解释成一个有符号十进制整数；
- `%e`, `%f`, `%g`, `%a`：把输入解释成一个浮点数（`%a` 是 C99 标准）；
- `%E`, `%F`, `%G`, `%A`：把输入解释成一个浮点数（`%A` 是 C99 标准）；
- `%p`：把输入解释成一个指针（一个地址）；
- `%s`：把输入解释成一个字符串；输入的内容以第一个非空白字符作为开始，并且包含直到下一个空白字符的全部字符。

常用的 `scanf（）` 转换修饰符：

- `*`：滞后赋值；
- `digit（s）`：最大字段宽度：在达到最大字段宽度或者遇到第一个空白字符时（不管哪个先发生都一样）停止对输入项的读取；
- `hh`：把整数读作 `signed char` 或 `unsigned char`；
- `ll`：把整数读作 `long long` 或者 `unsigned long long`（C99）。

如果 `scanf（）` 没有读取任何项目（当它期望一个数字而您却键入了一个非数字字符串时就会发生这种情况），`scanf（）` 会返回值 0. 当它检测到 “文件结尾”（end of file）时，它返回 EOF（EOF 是在文件 `stdio.h` 中定义的特殊值。一般，`#define` 指令把 EOF 的值定义为 -1）。
在 `scanf（）` 中 `*` 提供截然不同的服务。当把它放在 `%` 和说明符之间时，它使函数跳过相应的输入项目。

###第 5 章 运算符、表达式和语句

####运算符术语

- 数据对象（data object）泛指数据存储区，数据存储区能用于保存值。
- 左值（lvalue）指用于标识一个特定的数据对象的名字或表达式。
- 右值（rvalue）指的是能赋给可修改的左值的量。
- 操作数（operand）是运算符操作的对象。

####除法运算符：/
整型数的除法运算和浮点型数的除法运算有很大不同。浮点类型的除法运算得出一个浮点数结果，而整数除法运算则产生一个整数结果。在 C 中，整数除法结果的小数部分都会被丢弃，这个过程称为截尾（truncation）。另外要是除法结果为负，则采用 “趋零截尾”。

####运算符的优先级
按优先级递减顺排列的运算符：
（运算符：结合性）

- `（）`：从左到右；
- `+ -`（一元运算符）：从右到左；
- `* /`：从左到右；
- `+ -`（二元运算符）：从左到右；
- `=`：从右到左；
（带一个操作数的运算符，例如负号和 `sizeof`，称为一元运算符。要求两个操作数的运算符，例如加法和乘法运算符，称为二元运算符。）

####sizeof 运算符
`sizeof` 运算符以字节为单位返回其操作数的大小（在 C 中，1 个字节被定义为 `char` 类型所占用空间的大小。一般 1 个字节通常是 8 位，有些字符集可能会使用更大的字节）。操作数可以是一个具体的数据对象（例如一个变量名），或者一个类型。如果它是一个类型（如 `float`），操作数必须被括在圆括号里。
C 规定 `sizeof` 返回 `size_t` 类型的值，C 的头文件系统可以使用 `typedef` 来使 `size_t` 在系统中作为 `unsigned int` 或 `unsigned long` 的同义词，这样当您使用 `size_t` 时，编译器会用适合的系统的标准类型来代替。
C 99 更进一步，把 `%zd` 作为用来显示 `size_t` 类型值的 `printf（）` 说明符，如果您的系统没有实现 `%zd`，可以试着使用 `%u` 或 `%lu` 代替。

####增量和减量运算符：++ 和 --
增量运算符（increment operator）即将其操作数的值增加一，有两种出现方式，前缀（prefix）模式和后缀（postfix）模式，两种模式的区别在于值的增加这一动作发生的准确时间不同。
增量和减量运算符有很高的结合优先级，只有圆括号比它们的优先级高，且增量运算符和减量运算符只能影响一个变量（或者更一般地讲，一个可修改的左值。）

####增量和减量运算符的使用原则

- 如果一个变量出现在同一个函数的多个参数中时，不要将增量或者减量运算符用于它上面；
- 当一个变量多次出现在一个表达式里时，不要将增量或减量运算符用到它的上面。

####表达式和语句
表达式（expression）是由运算符和操作数组成构成的，一些表达式是多个较小的表达式的组合，这些小的表达式被称为子表达式（subexpression）。
语句（statement）是构造程序的基本成分，程序（program）是一系列带有某种必需的标点的语句集合。一个语句是一条完整的计算机指令，在 C 中，语句结束处用一个分号标识。
- 赋值语句（assignment statement）为一个变量分配一个值。
- 函数语句（function statement）引起函数的执行。
- while 语句属于一类有时被称为 “结构化语句”（structured statement）的语句。
- 副作用（side effect）是对数据对象或文件的修改。
- 一个顺序点（sequence point）是程序执行中的一点：在该点处，所有的副作用都在进入下一步前被计算。在 C 中，语句里的分号标识了一个顺序点，它意味着在一个语句中赋值运算符、增量运算符及减量运算符所做的全部改变必须在程序进入下一个语句前发生。
- 复合语句（compound statement）是使用花括号组织起来的两个或更多的语句，也被称为一个代码块（block）。

####类型转化
类型转换的基本规则：

- 提升（promotion）即在需要情况下被转换成较大的类型；
- 在包含两种数据类型的任何运算里，两个值都被转换成两种类型里较高的级别；
- 类型级别从高到低的顺序是 `long double`, `double`, `float`, `unsigned long long`, `long long`, `unsigned long`, `long`, `unsigned int` 和 `int`. 一个可能的例外是当 long 和 int 具有相同大小时，此时 unsigned int 比 long 级别更高。
- 在赋值语句中，计算的最后结果被转换成将要被赋予值得那个变量的类型，可能像规则 1 中导致提升，也可能导致降级（demotion），降级是将一个值转换成一个更低级别的类型；
- 当作为函数的参数被传递时，char 和 short 会被转换成 int，float 会被转换成 double（可以通过函数原型来阻止自动提升的发生）。

提升通常是一个平滑的无损害过程，但是降级可能导致真正的问题，比如趋零截尾或舍入。

####指派运算符
在计算中需要准确的类型转换，或者需要在程序中表明您是知道您正在做类型转换的，完成这一任务的方法被称为指派（cast），其步骤是在某个量的前面放置用圆括号括起来的被希望转换成的类型名。圆括号和类型名一起构成了指派运算符（cast operator），指派运算符的一般形式如下：

	(type)

####参数与参量
术语参数（argument）和参量（parameter）可以互换使用，但 C99 文档规定：对实际参数或者实际参量使用术语参数，对形式参量或者形式参数使用术语参量。遵循这个约定，我们可以说参量是变量，而参数是由函数调用提供的值，并且将它赋给相对应的参量。

###第 6 章 C 控制语句：循环

####运算符的优先级
（优先级从高到低）

	（）
	-   +   ++   --   sizeof   (type)
	*   /   %
	+   -
	<   >   <=   >=
	==   !=
	=

####赋值运算符与逗号运算符
赋值运算符（使用指定的操作根据其右边的值来更新其左边的变量）：

- `+=`：把右边的值加到左边的变量上；
- `-=`：从左边的变量中减去右边的值；
- `*=`：把左边的变量乘以右边的值；
- `/=`：把左边的变量除以右边的值；
- `%=`：给出左边的变量除以右边的值之后的余数。

逗号运算符，把两个表达式链接成为一个表达式，并保证最左边的表达式最先计算。用在 for 循环的控制表达式中以包含多个信息。整个表达式的值是右边表达式的值。

####退出条件循环：do while
do while 语句创建了一个在判断表达式为假（或零）之前重复执行的循环。do while 语句是一个退出条件循环，是否再次执行循环的决定是在执行了一次循环之后做出的。因此循环必须至少被执行一次。该形式的 statement 部分可以是一个简单语句或一个复合语句。

形式：

    do
        statement
    while (expression);


####嵌套循环
嵌套循环（nested loop）是指在另一个循环之内的循环。通常使用嵌套循环来按行按列显示数据，也就是说一个循环处理一行中的所有列，而另一个循环则处理所有的行。

####数组
用于标识数组元素的数字称为下标（subscript）、索引（index）或偏移量（offset）。下标必须是整数，而且是从 0 开始。

####具有返回值的函数
声明函数、调用函数、定义函数、使用 return 关键字，这些就是在定义并使用具有返回值的函数时的基本要素。

#####总结
典型的 while 循环设计看上去就像这样：

    get first value
    while (value meets test) {
        process the value
        get next value
    }

同样工作的 for 循环看上去像这样：

    for (get first value; value meets test; get next value)
        process the value


###第 7 章 C 控制语句：分支和跳转

####if 语句
if 语句被称为分支语句（branching statement）或选择语句（selection statement），因为它提供了一个交汇点，在此处程序需要选择两条分支中的一条前进，一般形式如下：

    if (expression)
        statement

如果 expression 求得的值为真（非零），就执行 statement；否则，跳过该语句。
if else 语句的通用形式为：

    if (expression)
        statement1
    else
        statement2


####getchar（）和 putchar（）
`getchar（）` 函数没有参数，它返回来自输入设备的下一个字符例如：

    //读取一下输入字符并将它的值赋给变量 ch：
    ch = getchar();
    //该语句与下面的语句有相同的效果：
    scanf ("%c", &ch);

`putchar（）` 函数打印它的参数，例如：

    //将先前赋给 ch 的值作为字符打印出来：
    putchar(ch);
    //该语句与下面的语句有相同的效果：
    printf ("%c", ch);

这两个函数通常都在 `stdio.h` 文件中定义，而且只是预处理器宏（macro），并不是真正的函数。

####ctype.h 系列字符函数

`ctype.h` 头文件包含了一系列标准的函数可以用来分析字符，例如 `isalpha( )`，这些函数接受一个字符作为参数，如果该字符属于某特定的种类则返回非零值（真），否则返回零（假）。

####多层嵌套的 if
在希望检验一个新数的时候就无须每次都重新运行程序，为这种循环研究出一个模型：

    prompt user
    while the scanf () return value is 1
        analyze the number and report results
        prompt user

输入循环的模型：

    while ((ch = getchar ()) != STOP)
    {
        ...
    }

下列每种 if 语句的形式中，语句部分可以是一个简单语句或者是一个复合语句。一个真表达式意味着它具有非零值。

形式 1：

    if (expression)
        statement
    //如果 expression 为真则执行 statement

形式 2：

    if (expression)
        statement1
    else
        statement2
    //如果 expression 为真，则执行 statement1；否则执行 statement2

形式 3：

    if (expression)
        statement1
    else if (expression2)
        statement2
    else
        statement3
    /* 如果 expression1 为真，则执行 statement1；如果 expression1 为假且 expression2 为真，则执行 statement2；否则，如果两个表达式都为假，执行 statement3.*/


####C 的逻辑运算符
C 有三个逻辑运算符（如果包含 iso646.h 头文件）：

1. `&&` （and） ：与
2. `|| ` （or）：或
3. `！` （not）：非

`! ` 运算符的优先级很高，它高于乘法运算，和增量运算符相同，仅次于圆括号。

`&&` 运算符的优先级高于 `||`，这二者的优先级都低于关系运算符且高于赋值运算符。

####条件表达式
条件表达式的一般形式：

    expression1 ? expression2 : expression3

如果 expression1 为真（非零），整个条件表达式的值和 expression2 的值相同。如果 expression1 为假（零），整个条件表达式的值等于 expression3 的值。

典型的例子是将两个值中得最大值赋给变量：

    max = (a > b) ? a : b;
    //如果 a 大于 b，那么 max 等于 a，否则等于 b


####continue 和 break
break 语句用于循环和 switch 中，而 continue 仅用于循环。

####switch 语句
switch 结构如下：

    switch (integer expression)
        {
        case constant1:
            statements         //可选；使用 break 跳至结尾处
        case constant2:
            statements         //可选；使用 break 跳至结尾处
        default:
            statements         //可选
        }

程序按照 expression 的值跳转到相应的 case 标签处。然后程序流程继续通过所有剩余的语句，直到再次由 break 语句重定向。expression 和 case 标签必须都是整型值（包括类型 char），并且标签必须是常量或者完全由常量组成的表达式。如果没有与表达式值相匹配的 case 标签，那么控制定位到标签 default 的语句，如果它存在的话。否则，控制传递给紧跟着 switch 语句的下一条语句。

如果选择是基于求一个浮点型变量或表达式的值，就不能使用 switch，如果变量必须落入某个范围，也不能很方便地使用 switch.

####goto 语句
goto 语句包括两个部分：goto 和一个标签名称。标签的命名遵循与命名变量相同的约定，例如：

    //格式：
    goto label:
    .
    .
    .
    label: statement

    //示例：
    goto part2;
    //为使上述语句工作，函数必须包含由 part2 标签定位的其他语句；
    //可以通过以标签名紧跟一个冒号来开始一条语句完成：
    part2: printf ("Refined analysis: \n");

不过在 C 中应尽量避免使用 goto 语句。

###第 8 章 字符输入/输出和输入确认

####缓冲区
缓冲分为两类：完全缓冲（fully buffered）I/O 和行缓冲（line-buffered）I/O。对完全缓冲输入来说，缓冲区满时被清空（内容被发送至其目的地）。这种类型的缓冲通常出现在文件输入中。缓冲区的大小取决于系统，但 512 字节和 4096 字节是常见的值。对行缓冲 I/O 来说，遇到一个换行字符时将被清空缓冲区。键盘输入是标准的行缓冲，因此按下回车键将清空缓冲区。

####文件、流和键盘输入
文件（file）是一块存储信息的存储器区域，通常被保存在某种类别的永久存储器上。
低级 I/O（low-level I/O）可以使用宿主操作系统的基本文件工具来处理文件。
标准 I/O 包（standard I/O package）包括创建用于处理文件的 I/O 函数的标准模型和标准集。
从概念上说，C 程序处理一个流而不是直接处理文件。流（stream）是一个理想化的数据流，实际输入或输出映射到这个数据流。这意味着具有不同属性的多种类型的输入由流表示，会具有更多统一的属性。于是打开文件的过程就成为将流与文件相关联，并通过流进行读写的过程。
键盘输入由一个被称为 stdin 的流表示，而到屏幕（或电传打字机、或其他输出设备）上的输出由一个被称为 stdout 的流表示。`getchar（）`、`putchar（）`、`printf（）` 和 `scanf（）` 函数都是标准 I/O 包的成员。

####文件结尾
C 判定文件结束位置的方法是让 `getchar（）`函数在到达文件结尾时返回一个特殊值，而不去管操作系统是如何检测文件结尾的。赋予该值的名称是 EOF（End Of File，文件尾）。因此，检测到文件尾时 `getchar（）` 的返回值是 EOF。scanf（）函数在检测到文件结尾时也返回 EOF。通常 EOF 在 stdio.h 文件中定义，如下所示：

    # define EOF (-1)

####重定向
两个重定向运算符 `<` 和 `>` 在 Unix, Linux 或 DOS 中所遵循的规则如下：

- 重定向运算符将一个可执行（executable）程序（包括标准的操作系统命令）与一个数据文件连接起来。该运算符不能用于一个数据文件与另一个数据文件的连接，也不能用于一个程序与另一个程序的连接。
- 使用这些运算符时，输入不能来自一个以上的文件，输出也不能定向至一个以上的文件。
- 除了偶尔在使用到一些对 Unix shell, Linux shell 或 DOS 具有特殊意义的字符时，名字和操作符之间的空格并不是必需的。

Unix、Linux 和 DOS 还有 >> 运算符，该运算符可使您向一个现有文件的末尾追加数据；还有管道运算符 `|`，它可以将一个程序的输出与第二个程序的输入连接起来。

可以通过操作系统对所有的程序使用重定向，或者仅仅是在 C 编译器允许的情况下对 C 程序使用重定向。比如，令 prog 为可执行程序的名字，并令 file1 和 file2 为文件名，示例如下：

    //将输出重定向到一个文件：
    prog > file1
    //将输入重定向为来自一个文件：
    prog < file2
    //组合重定向：
    prog < file2 > file1
    prog > file1 < file2
    //两种形式都使用 file2 作为输入，使用 file1 作为输出


####混合输入数字和字符
`getchar（）` 和 `scanf（）` 这两个函数不能很好地混合在一起使用，因为 `getchar（）` 读取每个字符，包括空格、制表符和换行符；而 `scanf（）` 在读取数字时则会跳过空格、制表符和换行符。

###第 9 章 函数

####函数
函数原型（function prototype）告知编译器函数类型，函数调用（function call）导致该函数的执行，而函数定义（function definition）则确切指定了该函数的具体功能。

注意：ANSI C 形式要求在每个变量前声明其类型，也就是说，不能像通常的变量声明那样使用变量列表来声明同一类型的变量。

####函数类型
函数应该进行类型声明，同时其类型应和返回值类型相同。而无返回值得函数应该被声明为 void 类型。

####尾递归
最简单的递归形式是把递归调用语句放在函数结尾即恰在 return 语句之前，这种形式被称为尾递归（tail recursion）或结尾递归（end recursion），因为递归调用出现在函数尾部。由于尾递归的作用相当于一条循环语句，所以它是最简单的递归形式。

####地址运算符：&
C 中最重要有时也是最复杂的概念之一就是指针（pointer），也就是用来存储地址的变量。
`%p` 是输出地址的说明符。

####指针
指针是一个其数值为地址的变量（或更一般地说是一个数据对象）。

####间接运算符：*
间接（indirection）运算符 *（也称作取值（dereferencing）运算符）来获取存放的数值（不要把这种一元运算符和表示乘法的二元运算符 * 相混淆）。

####与指针相关的运算符总结
地址运算符：`&`（后跟一个变量名时，`&` 给出该变量的地址）；

间接运算符：*（当后跟一个指针名或地址时，* 给出存储在被指向地址中的数值）。

示例如下：

    nurse = 22;
    ptr = &nurse;    //指向 nurse 的指针
    val = *ptr;      //将 ptr 指向的值赋给 val
    /*上述语句实现的功能是把数值 22 赋给变量 val*/


####指针声明
指针声明的形式如下：

    int * pi;          //pi 是指向一个整数变量的指针
    char * pc;         //pc 是指向一个字符变量的指针
    float * pf, * pg;  //pf 和 pg 是指向浮点变量的指针


类型标识符表明了被指向变量的类型，而星号（ * ）表示该变量为一指针。声明 int * pi; 的意思是 pi 是一个指针，而且 *pi 是 int 类型的。

###第 10 章 数组和指针

####数组
- 数组（array）由一系列类型相同的元素构成。可以使用声明来告诉编译器您需要一个数组。数组声明（array declaration）中包括数组元素的数组和元素的类型。编译器根据这些信息创建合适的数组。
- 数组声明中的方括号内的数字指明了数组所包含的元素数目。要访问数组中的元素，可以使用下标数字来表示单个元素，下表数字也称为索引（index），是从 0 开始计数的。
- 数组的赋值可以使用循环对元素逐个赋值。C 不支持把数组作为一个整体来进行赋值，也不支持用花括号括起来的列表形式进行赋值（初始化的时候除外）。

####指定初始化项目（C99）
C99 增加了指定初始化项目（designed initializer），此特性允许选择对某些元素进行初始化。对于通常的初始化，在初始化一个或多个元素后，未经初始化的元素都将被设置为 0.

指定初始化项目有两个重要特性：

1. 如果在一个指定初始化项目后跟有不止一个值，则这些数值将用来对后续的数组元素初始化；
2. 如果多次对一个元素进行初始化，则最后的一次初始化有效。

####数组边界
使用数组的时候，需要注意数组索引不能超过数组边界，因为编译器不检查索引的合法性，在标准 C 中，如果使用了错误的索引，程序执行结果是不可知的。

使用数组中需要记住的一件简单的事是，数组的计数是从 0 开始的。避免出现这个问题比较简单的方法是：在数组声明中使用符号常量，然后程序中需要使用数组大小的地方都直接引用符号常量，这样做的好处是保证整个程序中数组的大小始终一致。

####声明数组参量
由于数组名就是数组首元素的地址，所以如果实际参数是一个数组名，那么形式参量必须是与之相匹配的指针。在（而且仅在）这种场合中，C 对于 int ar[ ] 和 int *ar 作出同样解释，即 ar 是指向 int 的指针。由于原型允许省略名称，因此下面的 4 种原型都是等价：

    int sum (int *ar, int n);
    int sum (int *, int);
    int sum (int ar[], int n);
    int sum (int [], int);
    //定义函数时，名称是不可以省略的。
    //因此，在定义时下面两种形式是等价的：
    int sum (int *ar, int n) {
        code
    }
    int sum (int ar[], int n) {
        code
    }


####指针的基本操作
下面的列表描述了可对指针变量执行的基本操作：

1. 赋值（assignment）——可以把一个地址赋给指针。通常使用数组名或地址运算符 & 来进行地址赋值。注意，地址应该和指针类型兼容，也就是说，不能把一个 double 类型的地址赋给一个指向 int 的指针，虽然 C99 允许使用类型指派这样做，但是不推荐使用这种方法。
2. 求值（value-finding）或取值（dereferencing）——运算符 * 可取出指针指向地址中存储的数值。
3. 取指针地址——指针变量同其他变量一样具有地址和数值，使用运算符 & 可以得到存储指针本身的地址。
4. 将一个整数加给指针——可以使用 + 运算符来把一个整数加给一个指针，或者把一个指针加给一个正数。两种情况下，这个整数都会和指针所指类型的字节相乘，然后所得的结果会加到初始地址上。
5. 增加指针的值——可以通过一般的加法或增量运算符来增加一个指针的值。对指向某数组元素的指针做增量运算，可以让指针指向该数组的下一个元素。
6. 从指针中减去一个整数——可以使用 - 运算符从一个指针中减去一个整数。指针必须是第一个操作数，或者是一个指向整数的指针。这个整数都会和指针所指类型的字节数相乘，然后所得的结果会从初始地址中减掉。
7. 减小指针的值——指针当然也可以做减量运算。可以使用前缀和后缀形式的增量和减量运算符。
8. 求差值（differencing）——可以求出两个指针间的差值。通常对分别指向同一个数组内两个元素的指针求差值，以求出元素之间的距离。差值的单位是相应类型的大小。有效指针差值运算的前提是参加运算的两个指针是指向同一个数组（或是其中之一指向数组后面的第一个地址）。指向两个不同数组的指针之间的差值运算可能会得到一个数值结果，但也可能会导致一个运行错误。
比较——可以使用关系运算符来比较两个指针的值，前提是两个指针具有相同的类型。
注意：这里有两种形式的减法，可以用一个指针减掉另一个指针得到一个整数，也可以从一个指针中减去一个整数得到一个指针。

####保护数组内容
如果不希望函数修改数据，可以在函数原型和定义的形式参量声明中使用关键字 const，这告诉编译器：函数应当把指定的数组作为包含常量数据的数组对待，这样，如果意外地使用了诸如 ar[i]++ 之类的表达式，编译器将会发现这个错误并生成一条错误消息，通知函数试图修改常量。

####变长数组
变长数组（VLA）中的 “变” 并不是表示在创建数组后，可以修改其大小。变长数组的大小在创建后就是保持不变的。“变” 的意思是说其维度大小可以用变量来指定。

变长数组允许动态分配存储单元。这表示可以在程序运行时指定数组的大小。常规的 C 数组是静态存储分配的，也就是说数组大小在编译时已经确定。这是因为数组大小是常量，所以编译器可以得到这些信息。

###第 11 章 字符串和字符串函数

####字符串常量
字符串常量（string constant），又称字符串文字（string literal），是指位于一对双引号中的任何字符。双引号里的字符加上编译器自动提供的结束标志 \0 字符，作为一个字符串被存储在内容里。程序中使用了几个这样的字符串常量，大多数是用作函数 `printf（）` 和 `puts（）` 的参数。注意，还可以用 #define 来定义字符串常量。

如果字符串文字中间没有间隔或者间隔的是空格符，ANSI C 会将其串联起来。

字符串常量属于静态存储（static storage）类。静态存储是指如果在一个函数中使用字符串常量，即使是多次调用了这个函数，该字符串在程序的整个运行过程中只存储一份。整个引号中的内容作为指向该字符串存储位置的指针。这一点与把数组名作为指向数组存储位置的指针类似。

####gets（）函数
`gets（）`（代表 get string）函数对于交互式程序非常方便。它从系统的标准输入设备（通常是键盘）获得一个字符串。因为字符串没有预定的长度，所以 `gets（）` 需要知道输入何时结束。解决办法是读字符串直到遇到一个换行字符（`\n`），按回车键可以产生这个字符。它读取换行符之前（不包括换行符）的所有字符，在这些字符后添加一个空字符（`\0`），然后把这个字符串交给调用它的程序。它将读取换行符并将其丢弃，这样下一次读取就会在新的一行开始。

`gets（）` 函数通过两种方式获得输入：

- 它使用一个地址把字符串赋予 name.
- gets（）的代码使用 return 关键字返回字符串的地址，程序把这个地址分配给 ptr。注意到 ptr 是一个 char 指针，这意味着 gets（）必须返回一个指向 char 的指针值。

如果出错或 `gets（）` 遇到文件结尾，它就返回一个空（或 0）地址，这个空地址被称为空指针，并用 `stdio.h` 里定义的常量 NULL 来表示，因此 `gets（）` 的错误检测可以被如下形式使用：

    while (gets (name) != NULL)

相对应，`getchar（）` 只返回一个值而没有参数：

    while ((ch = getchar ()) != EOF)

另外注意，不要混淆空指针和空字符。空指针是一个地址，而空字符是一个 char 类型的数据对象，其值为 0.数值上两者都可以用 0 表示。但是它们的概念不同：NULL 是一个指针，而 0 是一个 char 类型的常量。

`gets（）` 函数的一个不足是它不检查预留存储区是否能够容纳实际输入的数据。多出来的字符简单地溢出到相邻的内存区。

####fgets（）函数和 gets（）函数的三点不同
`fgts（）` 需要第二个参数来说明最大读入字符数。如果这个参数值为 n，`fgets（）` 就会读取最多 n-1 个字符或者读完一个换行符为止，由这二者中最先满足的那个来结束输入。
如果 `fgets（）` 读取到换行符，就会把它存到字符串里，而不是像 `gets（）` 那样丢弃它。
它还需要第三个参数来说明读哪一个文件。从键盘上读数据时，可以使用 `stdin`（代表 standard input）作为该参数，这个标识符在 `stdio.h` 中定义。

####fgets（）函数和 gets（）函数的不足
`fgets（）` 函数有一个不足之处：它会把换行符存储到字符串里，这样每次显示字符串时就会显示换行符。

由于 `gets（）` 函数不检查目标数组是否能够容纳输入，所以很不安全。之前在 Unix 网络上传播的 “蠕虫（worm）” 病毒就是利用了这一特点，用很长的输入覆盖操作系统的代码。因此对于重要的编程，应该使用 `fgets（` 而不是 `gets（）`.

####fputs（）函数与 puts（）函数的主要区别

`fputs（）` 函数是 `puts（）` 的面向文件版本。

- fputs（）需要第二个参数来说明要写的文件。可以使用 stdout（代表 standard output）作为参数来进行输出显示，stdout 在 stdio.h 中定义。
- 与 puts（）不同，fputs（）并不为输出自动添加换行符。

注意：`gets（）` 丢掉输入里的换行符，但是 `puts（）` 为输出添加换行符。另一方面，`fgets（）` 存储输入中的换行符，而 `fputs（）` 也不为输出添加换行符。

####字符串函数
C 库提供了许多处理字符串的函数：ANSI C 用头文件 `string.h` 给出这些函数的原型。一些最有用和最常用的函数：`strlen（）`, `strcat（）`, `strncat（）`, `strcmp（）`, `strncmp（）`, `strcpy（）`, `strncpy（）`.

####strcat（）
`strcat（）`（代表 string concatenation）函数接受两个字符串参数。它将第二个字符串的一份拷贝添加到第一个字符串的结尾，从而使第一个字符串成为一个新的组合字符串，第二个字符串并没有改变。`strcat（）` 函数是 `char*`（指向 char 的指针）类型。这个函数返回它的第一个参数的值，即其后添加了第二个字符串的那个字符串中第一个字符的地址。

####strcmp（）的返回值
如果 `strcmp（）` 比较的字符串不相同，第一个字符串在字符表中的顺序先于第二个字符串，则 `strcmp（）` 函数返回的是负数；相反，返回的就是正数。返回的数值是二者的 ASCII 编码值之差。

`strcmp（）` 是比较所有字符，而不仅仅是字母，因此 `strcmp（）` 是按机器编码顺序（collating sequence）进行比较的。这意味着字符的比较是根据它们的数字表示法，一般是 ASCII 值。

####strcpy（）
`strcpy（）` 函数在字符串运算中的作用等价于赋值运算符。

`strcpy（）` 接受两个字符串指针参数。指向最初字符串的第二个指针可以是一个已声明的指针、数组名或字符串常量。指向复制字符串的第一个指针应指向空间大到足够容纳该字符串的数据对象，比如一个数组。记住，声明一个数组将为数据分配存储空间；而声明一个指针只为地址分配存储空间。

`strcpy（）` 函数还有另外两个有用的属性。首先，它是 `char* ` 类型，它返回的是第一个参数的值，即一个字符的地址；其次，第一个参数不需要指向数组的开始，这样就可以只复制数组的一部分。

####其他字符串函数

ANSI C 库有 20 多个处理字符串的函数，总结了一些最常用的：

    char *strcpy (char * s1, const char * s2);
    //strcpy 函数把 s2 指向的字符串（包括空字符）复制到 s1 指向的位置，返回值是 s1

    char *strncpy (char * s1, const char * s2, size_t n);

    char *strcat (char * s1, const, char * s2);
    //s2 指向的字符串被复制到 s1 指向字符串的结尾。复制过来的 s2 所指字符串的第一个字符覆盖了 s1 所指字符串结尾的空字符。返回值是 s1.

    char *strncat (char * s1, const char * s2, size_t n);

    int strcmp (const char * s1, const char * s2);

    int strncmp (const char * s1, const char * s2, size_t n);

    char *strchr (const char * s, int c);

    char *strpbrk (const char * s1, const char * s2);

    char *strrchr (const char * s, int c);

    char *strstr (const char * s1, const char * s2);

    size_t strlen (const char * s);


###第 12 章 存储类、链接和内存管理

####存储类
C 为变量提供了 5 种不同的存储类型，或称存储类。还有基于指针的第 6 种存储类型。可以按照一个变量（更一般地，一个数据对象）的存储时期（storage duration）描述它，也可以按照它的作用域（scope）以及它的链接（linkage）来描述它。

五种存储类分别是：

- 自动——在一个代码块内（或在一个函数头部作为参量）声明的变量，无论有没有存储类修饰符 auto，都属于自动存储类。该类具有自动存储时期、代码块作用域和空链接。如未经初始化，它的值是不定的。
- 寄存器——在一个代码块内（或在一个函数头部作为参量）使用存储类修饰符 register 声明的变量属于寄存器存储类。该类具有自动存储时期、代码块作用域和空链接，并且您无法获得其地址。把一个变量声明为寄存器变量可以指示编译器提供可用的最快访问。如未经初始化，它的值是不定的。
- 具有外部链接的静态——在所欲函数外部定义、未使用存储类修饰符 static 的变量属于静态、外部链接存储类。该类具有静态存储时期、文件作用域和外部链接，仅在编译时初始化一次。如未明确初始化，它的字节都被设定为 0.
- 具有内部链接的静态——在所有函数外部定义、使用存储类修饰符 static 的变量属于静态、内部链接存储类。该类具有静态存储时期、文件作用域和内部链接，仅在编译时初始化一次。如未明确初始化，它的字节都被设定为 0.
- 空链接的静态——在一个代码块内使用存储类修饰符 static 声明的变量属于静态空链接存储类。该类具有静态存储时期、代码块作用域和空链接，仅在编译时初始化一次。如未明确初始化，它的字节都被设定为 0。

####作用域
作用域描述了程序中可以访问一个标识符的一个或多个区域。在代码块中定义的变量具有代码块作用域（block scope），从该变量被定义的地方到包含该定义的代码块的末尾该变量均可见。

函数原型作用域（function prototype scope）适用于函数原型中使用的变量名。

一个在所有函数之外定义的变量具有文件作用域（file scope）。具有文件作用域的变量从它定义处到包含该定义的文件结尾处都是可见的。

####链接
一个 C 变量具有下列链接之一：外部链接（external linkage），内部链接（internal linkage），或空链接（no linkage）。具有代码块作用域或者函数原型作用域的变量有空链接，意味着它们是由其定义所在的代码块或函数原型所私有的。具有文件作用域的变量可能有内部或者外部链接。一个具有外部链接的变量可以在一个多文件程序的任何地方使用。一个具有内部链接的变量可以在一个文件的任何地方使用。

####存储时期
一个 C 变量有以下两种存储时期之一：静态存储时期（static storage duration）和自动存储时期（automatic storage duration）。如果一个变量具有静态存储时期，它在程序执行期间将一直存在。具有文件作用域的变量具有静态存储时期。注意对于具有文件作用域的变量，关键词 `static` 表明链接类型，并非存储时期。一个使用 `static` 声明了的文件作用域变量具有内部链接，而所有的文件作用域变量，无论它具有内部链接，还是具有外部链接，都具有静态存储时期。

####自动变量
属于自动存储类的变量具有自动存储时期、代码块作用域和空链接。默认情况下，在代码或函数的头部定义的任意变量都属于自动存储类。

为了表明有意覆盖一个外部函数定义，或者为了表明不能把变量改变为其他存储类这一点很重要，可以显式地使用关键字 auto，关键字 auto 称为存储类说明符（storage class specifier）.

####具有代码块作用域的静态变量
静态变量（static variable）中的 “静态” 实际上是指变量的位置固定不动。具有文件作用域的变量自动（也是必须得）具有静态存储时期。也可以创建具有代码块作用域，兼具存储的局部变量。

####具有外部链接的静态变量
具有外部链接的静态变量具有文件作用域、外部链接和静态存储时期。这一类型有时被称为外部存储类（external storage class），这一类型的变量被称为外部变量（external variable）。把变量的定义声明放在所有函数之外，即创建了一个外部变量。为了使程序更加清晰，可以在使用外部变量的函数中通过使用 `extern` 关键字来再次声明它。如果变量是在别的文件中定义的，使用 `extern` 来声明该变量就是必须的。

####存储类说明符
C 语言中有 5 个作为存储类说明符的关键字，分别是：`auto`, `register`, `static`, `extern` 和 `typedef`。关键字 `typedef` 与内存存储无关，由于语法原因被归入此类。特别地，不可以在一个声明中使用一个以上存储类说明符，这意味着不能将其他任一存储类说明符作为 `typedef` 的一部分。

说明符 `auto` 表明一个变量具有自动存储时期。该说明符只能用在具有代码块作用域的变量声明中，而这样的变量已经拥有自动存储时期，因此它主要用来明确指出意图，使程序更易读。

说明符 `register` 也只能用于具有代码块作用域的变量。它将一个变量归入寄存器存储类，这相当于请求将该变量存储在一个寄存器内，以更快地存取。它的使用也使您不能获得变量的地址。

说明符 `static` 在用于具有代码块作用域的变量的声明时，使该变量具有静态存储时期，从而得以在程序运行期间（即使在包含该变量的代码块并没有运行时）存在并保留其值。变量仍具有代码块作用域和空链接。static 用于具有文件作用域的变量的声明时，表明该变量具有内部链接。

说明符 `extern` 表明您在声明一个已经在别处定义了的变量。如果包含 `extern` 的声明具有文件作用域，所指向的变量必然具有外部链接。如果包含 `extern`的声明具有代码块作用域，所指向的变量可能具有外部链接也可能具有内部链接，这取决于该变量的声明。

####malloc（）
`malloc（）` 函数可以在程序运行时分配更多的内存，它接受一个参数：所需内存字节数。然后 `malloc（）` 找到可用内存中一个大小适合的块。内存是匿名的，也就是说，`malloc（）` 分配了内存，但没有为它指定名字。然而，它却可以返回那块内存第一个字节的地址。因此，您可以把那个地址赋值给一个指针变量。

####创建数组的方法
创建一个数组有三种方法：

1. 声明一个数组，声明时用常量表达式指定数组维数，然后可以用数组名访问数组元素。
2. 声明一个变长数组，声明时用变量表达式指定数组维数，然后用数组名来访问数组元素。
3. 声明一个指针，调用 `malloc（）`，然后使用该指针来访问数组元素。


####动态内存分配与变长数组
变长数组（Variable-Length Array, VLA）与 `malloc（）` 在功能上有些一致，但有一个区别在于 VLA 是自动存储的。自动存储的结果之一就是 VLA 所用内存空间在运行完定义部分之后会自动释放。另一方面，使用由 `malloc（）` 创建的数组不必局限在一个函数中。例如，函数可以创建一个数组并返回指针，供调用该函数的函数访问。接着，后者可以在它结束时调用 `free（）`。`free（）` 可以使用不同于 `malloc（）` 指针的指针变量；必须一致的是指针中存储的地址。

####ANSI C 的类型限定词
C90 增加了两个属性：不变性和易变性。这些属性是通过关键字 `const` 和 `volatile` 声明的，这样就创建了受限类型（qualified type）。C99 标准添加了第三个限定词 `restrict`，用以方便编译器优化。

C99 授予类型限定词一个新属性：幂等的（idempotent），其实只意味着可以在一个声明中不止一次地使用同一个限定词，多余的将被忽略掉。

###第 13 章 文件输入/输出

####标准文件
C 程序自动为您打开 3 个文件：标准输入（standard input），标准输出（standard output）和标准错误输出（standard error output）。

用标准输入为您的程序提供输入是很自然的事情，它是 `getchar（）`、`gets（）` 和 `scanf（）` 读取的文件。标准输出是常用的程序输出对象，为 `putchar（）`、`puts（）` 和 `printf（）` 所使用。

####fopen（）函数
程序使用 `fopen（）` 打开文件，这一函数在 `stdio.h` 中声明。它的第一个参数是要打开的文件名；更确切地说，是包含该文件名的字符串地址。第二个参数是用于指定文件打开模式的一个字符串。

注意：如果使用任何一种 “w” 模式打开一个已有的文件，文件内容将被删除，以编程序以一个空文件开始操作。

程序成功地打开一个文件后，`fopen（）` 函数返回一个文件指针（file pointer），其他 I/O 函数用这个指针来指定该文件。文件指针是一种指向 `FILE` 的指针：`FILE` 是 `stdio.h` 中定义的一种派生类型，该指针并不指向实际的文件，而是指向一个关于文件的信息的数据包，其中包括文件 I/O 使用的缓冲区信息。

如果不能打开文件，`fopen（）` 函数返回空指针（也是在 `stdio.h` 中定义的）。磁盘已满，文件名非法、存取权限不够或者硬件问题等都会导致 `fopen（）` 函数执行失败。

####fclose（）函数
`fclose（fp）` 函数关闭由指针 `fp` 指定的文件，同时根据需要刷新缓冲区。更正规的程序也许还要检查是否成功关闭了文件。如果文件成功关闭，`fclose（）` 函数将返回值 0，否则返回 EOF。

磁盘已满、磁盘被移走或者出现 I/O 错误等都会导致 `fclose（）` 函数执行失败。

####fseek（）函数
在 `fseek（）` 的三个参数中，第一个参数是一个指向被搜索文件的 FILE 指针。

`fseek（）` 第二个参数被称为偏移量（offset），表示从起始点开始要移动的距离。这个参数必须是一个 `long` 类型的值，可以为正（前移）、负（后移），也可以为零（保持不动）。

第三个参数是模式，用来标识起始点。在 ANSI 下，`stdio.h` 头文件指定了三种模式常量：SEEK_SET（文件开始）,
SEEK_CUR（当前位置）,
SEEK_END（文件结尾）。

如果一切正常，`fseek（）` 的返回值为 0.如果有错误出现，例如试图移动超出文件范围，则 `fseek（）` 的返回值为 -1.

####ftell（）函数
`ftell（）` 函数为 `long` 类型，它返回文件的当前位置。在 ANSI 下，`ftell（）` 函数在 `stdio.h` 头文件中被声明。像在 ANSI C 下，`ftell（）` 函数通过返回距文件开始处的字节数来确定文件的位置，这种定义适用于以二进制模式打开的文件，但是对于以文本模式打开的文件来讲，不一定是这样。

###第 14 章 结构和其他数据形式

####结构变量
结构变量（structure variable）的组成部分称为成员（member）或字段（field），关于结构变量有三个必须掌握的重要技巧：

1. 建立结构的格式或布局；
2. 声明遵循该布局的变量；
3. 获取对一个结构变量的各个部件的访问。


####建立结构声明
结构声明（structure declaration）描述了组成这类对象的元素，有时候，也把结构声明叫做模板，因为它勾勒出数据该如何存储。

使用关键字 `struct` 表示接下来是一个结构。

标记名是可选的，但是在一个地方定义结构设计，而在其他地方定义实际的结构变量时，必须使用标记。

如果想多次使用一个结构模板，就需要使用带有标记的形式；或者可以使用 `typedef`。

####访问结构成员
结构就像是一个 “超级数组”，在这个超级数组内，一个元素可以是 `char` 类型，下一个元素可以是 `float` 类型，再下一个可以是 `int` 数组。使用下标可以访问一个数组的各个元素。

应使用结构成员运算符点 `.` 访问结构中得各个成员。例如，library.value 就是指 library 的 value 部分。

####结构的指定初始化项目
C99 支持结构的指定初始化项目，其语法与数组的指定初始化项目相似。只是，结构的指定初始化项目使用点运算符和成员名（而不是方括号和索引值）来标识具体的元素。示例如下：

    //只初始化 book 结构的成员 value
    struct book surprise = { .value = 10.99};
    //也可以按照任意的顺序使用指定初始化项目：
    struct book gift = { .value = 25.99,
                         .author = "James Broadfool",
                         .title = "Rue for the Toad"};


####结构和内存
因为结构数组是一个自动存储类的对象，所以这些信息通常会放置在堆栈里。如果编译器使用了一个相对于结构数组过小的默认大小的堆栈空间，可能就会得到一个有关堆栈大小或者堆栈溢出的运行时错误。为了满足需要，可以使用编译器选项把堆栈大小设置为更大的值以容纳结构数组，或者可以将数组设为静态的或外部的（这样就不会把数组放在堆栈里），也可以将数组的大小减小。

####使用指针访问结构成员

第一种，也是最常用的方法，是使用运算符 `->`，示例如下：

    运算符示例" >him->income is fellow[0].income if him == &fellow[0]

换句话说，后跟 `->` 运算符的结构指针和后跟 .（点）运算符的结构名是一样的（不能使用 him.income，因为 him 不是一个结构名），务必要注意到 him 是一个指针，而 him->income 是被指向结构的一个成员。

第二种指定结构成员的方法如下列序列：如果 `him=&fellow[0]`，那么 `*him=fellow[0]`，`&` 和 `*` 是一对互逆的运算符，因此可以做如下替代：

    fellow[0].income == (*him).income
    //必须有圆括号，因为 .(点)运算符比 * 的优先级高


####伸缩型数组成员（C99）
C99 具有一个称为伸缩型数组成员（flexible array member）的新特性，利用这一特性可以声明最后一个成员是一个具有特殊属性的数组的结构。该数组成员的特殊属性之一是它不存在，至少不立即存在。第二个属性是您可以编写适合的代码使用这个伸缩型数组成员，就像它确实存在并且拥有您需要的任何数目的元素一样。

声明一个伸缩型数组成员的规则：

- 伸缩型数组成员必须是最后一个数组成员；
- 结构中必须至少有一个其他成员；
- 伸缩型数组就像普通数组一样被声明，除了它的方括号内是空的。

####联合简介
联合（union）是一个能在同一个存储空间里（但不同时）存储不同类型数据的数据类型。一个典型的应用是一种表，设计它是用来以某种既没有规律，事先也未知的顺序保存混合类型数据，使用联合类型的数组，可以创建相同大小单元的数组，每个单元都能存储多种类型的数组。

联合是以与结构同样的方式建立的，也是需要有一个联合模板和一个联合变量。以下是一个带有标记的联合模板的例子：

    union hold {
        int digit;
        double bigfl;
        char letter;
    };


####总结：结构和联合运算符
成员运算符 `.` 和结构或联合名称一起使用，用来指定结构或联合的成员。如果 `name` 是一个结构名，`member` 是一个由结构模板指定的成员，下面就表示了该结构的这个成员：

    name.member
    //name.member 的类型就是 member 的类型。成员运算符也可以用同样方式用于联合。
    //例如：
    struct (
            int code;
            float cost;
    } item;

    item.code = 1265
    //最后一条语句将一个值赋给结构 item 的成员 code。

间接成员运算符 `->` 与指向结构或联合的指针一起使用，用来指明结构或联合的成员。假设 ptrstr 是一个指向结构的指针，member 是由该结构模板指定的一个成员，示例如下：

     示例" >ptrstr->member
    //这个表达式表示被指向的结构的成员。间接成员运算符可以用同样方式用于联合。
    //例如：
    struct {
        int code;
        float cost;
    } item, * ptrst;
    ptrst = &item;
    ptrst->code = 3451;
    //最后一条语句将一个 int 值赋给 item 的成员 code。
    //以下三个表达式是等价的：
    ptrst->code
    item.code
    (*ptrst).code


####枚举类型
使用枚举类型（enumerated type）声明代表整数常量的符号名称。通过使用关键字 enumeration，可以创建一个新 “类型” 并指定它可以具有的值（实际上，enum 常量是 `int` 类型的，因此在使用 `int` 类型的任何地方都可以使用它）。枚举类型的目的是提高程序的可读性，它的语法与结构的语法相同。

####共享的名字空间
C 使用术语名字空间（namespace）来表示识别一个名字的程序部分。作用域是这个概念的一部分；名字相同但具有不同作用域的两个变量不会冲突；而名字相同并在相同作用域中的两个变量就会冲突。

名字空间是分类别的。在一个特定作用域内的结构标记、联合标记以及枚举标记都共享一个名字空间，并且这个名字空间与普通变量使用的名字空间是不同的。这意味着，可以在同一个作用域内对一个变量和一个标记使用同一个名字，而不会产生错误；但是不能在同一作用域内使用名字相同的两个标记或名字相同的两个变量。

用两种不同的方式使用同一标识符会造成混乱；而且，C++ 不允许在同一个作用域内对一个变量和一个标记使用同一个名字，因为它把标记和变量名放在同一个名字空间中。

####typedef
typedef 工具是一种高级数据特性，它使您能够为某一类型创建您自己的名字。在这个方面，它和 `#define` 相似，但是它们有三个不同之处：

- 与 `#define` 不同，`typedef` 给出的符号名称仅限于对类型，而不是对值；
- `typedef` 的解释由编译器，而不是预处理器执行；
- 虽然它的范围有限，但在其受限范围内，`typedef` 比 `#define` 更灵活。


####奇特的声明
当进行一个声明时，可以添加一个修饰符来修饰名称（或标识符），声明时可以使用的修饰符：

- `*`（表示一个指针）；
- `( )`（表示一个函数）；
- `[ ]`（表示一个数组）。

声明一个指向特定函数类型的指针，首先声明一个该类型的函数，然后用（* pf）形式的表达式代替函数名称；pf 就成为可指向那种类型函数的指针了。

###第 15 章 位操作

####有符号整数
有符号数的表示方法是由硬件决定的，符号量（sign-magnitude）表示法就是保留 1 位（比如高位）来表示数的符号，这个方法有一个缺点就是有两个零（+0 和 -0）。

二进制补码（two's-complement）方法是当今最普遍的系统。在这种情况下，使用最后 7 位表示从 0 到 127 的值，同时高位设置为 0。这部分与符号量方法相同。同样的，如果高位是 1，那么该值为负。区别在于确定该负数值得方法是从一个 9 位组合 100000000（256 的二进制形式）中减去一个负数的位着，结果是该负数值的数量。

二进制反码（one's-complement）方法是通过反转位组合中的每一位以形成一个数的负数。

####位逻辑运算符

- `~`（二进制反码或按位取反，一元运算符 `~`  将每个 1 变成 0，将每个 0 变为 1）；
- `&`（位与，AND，二进制运算符 `&` 通过对两个操作数逐位进行比较产生一个新值。对于每个位，只有两个操作数的对应位都为 1 时结果才为 1，用真/假来描述，只有两个位操作都为真结果才为真）；
- `|`（位或，OR，二进制运算符 | 通过对两个操作数逐位进行比较产生一个新值。对于每个位，如果其中任意操作数中对应的位为 1，那么结果位就为 1，用真/假来描述，如果任意一个位操作数为真，或两个都为真，那么结果为真）；
- `^`（位异或，二进制运算符 `^` 对两个操作数逐位进行比较。对于每个位，如果操作数中得对应位有一个为 1，但是不都为 1，那么结果为 1，用真/假来描述，如果两个位操作数中有一个为真，但是不都为真，那么结果为真）。


####用法：掩码
“位与” 运算符通常跟掩码一起使用。掩码是某些位设为开（1）而某些位设置为关（0）的位组合。因为任何位使用 & 运算符与 0 组合都得 0，所以可以将掩码中的 0 看作不透明，将 1 看作透明，这个过程称为 “使用掩码”。示例如下：

    //假设定义符号常量 MASK 为 2，即二进制的 00000010
    flags = flags & MASK;
    //可以通过使用 “与-赋值” 运算符来简化代码
    flags &= MASK;
    //一种常见的 C 用法如下所示：
    ch &= 0xff; /* 或 ch &= 0377; */
    //值 0xff 的二进制形式为 11111111,十进制形式为 0377。该掩码留下 ch 的最后 8 位，将其余位设为 0。无论最初的 ch 是 8 位、16 位或是更多，都将最终的值修整到一个字节中。


####用法：打开位
可以使用 “位或” 运算符打开一个值中特定的位，同时保持其他位不变。因为任何位使用 `|` 运算符与 0 相结合结果为该位本身，任何位使用 `|` 运算符与 1 组合结果为 1.

####用法：关闭位
不影响其他位，同时能够将特定的位关闭与能够将特定的位打开一样是有用的。假设想关闭变量 flags 中的位 1。MASK 仍然只有位 1 是打开的。可以如下操作：

    flags = flags & -MASK


####用法：转置位
转置（toggling）一个位表示如果该位打开，则关闭该位；如果该位关闭，则打开该位。可以使用 “位异或” 运算符来转置一个位。其思想是如果 b 是一个位（1 或 0），那么如果 b 为 1 则 1^b 为 0，如果 b 为 0 则 1^b 为 1。而且，无论 b 的值是 0 还是 1，0^b 的值为 b。

####用法：查看一位的值
如果希望查看 flag 的位 1 是否为 1，不能简单地比较 flag 和 MASK，必须屏蔽 flag 中的其他位，以便只把 flag 中的位 1 和 MASK 相比较：

    if ((flag & MASK) == MASK)
        put ("Wow!");

位运算符的优先级低于 `==`，因此需要在 flag&MASK 的两侧加上圆括号。

为了避免信息漏过边界，位掩码至少应该与其所屏蔽的值具有相同的宽度。

####左移：<<
左移运算符 `<<` 将其左侧操作数的值得每位向左移动，移动的位数由其右侧操作数指定。空出的位用 0 填充，并且丢弃移出左侧操作数末端的位。

该操作产生一个新位值，但是不改变其操作数。也可以使用左移-赋值运算符 `<<=` 来实际改变一个变量的值。

####右移：>>
右移位运算符 `>>` 将其左侧操作数的值每位向右移动，移动的位数由其右侧操作数指定。丢弃移出左侧操作数右端的位。对于 `unsigned` 类型，使用 0 填充左端空出的位。对于有符号类型，结果依赖于机器。空出的位可能用 0 填充，或者使用符号（最左端的）位的副本填充。

####用法：移位运算符
移位运算符能够提供快捷、高效的（依赖于硬件）对 2 的幂的乘法和除法：

- number<<n（number 乘以 2 的 n 次幂）
- number>>n（如果 number 非负，则用 number 除以 2 的 n 次幂）


####位字段
对位进行操作的第二种方法是使用位字段（bit field），位字段是一个 `signed int` 或 `unsigned int` 中一组相邻的位（C99 还允许 _Bool 类型位字段）。位字段由一个结构声明建立，该结构声明为每个字段提供标签，并决定字段的宽度。

如果声明的总位数超过一个 `unsigned int` 大小，那将会占用下一个 `unsigned int` 存储位置。不允许一个字段超越两个 `unsigned int` 之间的边界。编译器自动地移位一个这样的字段定义，使字段按 `unsigned int` 边界对齐。发生这种情况时，会在第一个 `unsigned int` 中留下一个未命名的洞。

###第 16 章 C 预处理器和 C 库

####明显常量：#define
每个 `#define` 行（即逻辑行）由三部分组成，预处理器指令（`#define` 自身），宏和主体（也称替换列表）。

####宏
宏可以用来代表值，它们被称为类对象宏（object-like macro, C 还有类函数宏）。宏的名字中不允许有空格，而且必须遵循 C 变量命名规则：只能使用字母、数字和下划线（ _ ），第一个字符不能为数字。

####主体
`#define` 的除了 `#define` 和宏的部分称为替换列表（replacement list）或主体（body）。预处理器在程序发现了宏的实例后，总会用实体代替该宏。从宏变成最终的替换文本的过程称为宏展开（macro expansion）。注意，可以使用标准的 C 注释方法在 `#define` 行中进行注释，在预处理器处理之前，每个注释都会被一个空格所代替。

####语言符号
从技术方面看，系统把宏的主体当作语言符号（token）类型字符串，而不是字符型字符串。C 预处理器中的语言符号是宏定义主体中的 “词（word）”。用空白字符把这些词分开。

####重定义常量
ANSI 标准将重定义常量（redefining a constant）认为是错误的，只允许新定义与旧定义完全相同。

####在 #define 中使用参数
通过使用参数，可以创建外形和作用都与函数相似的类函数宏（function-like macro）。宏的参数也用圆括号括起来，因此，带参数的宏外形与函数非常相似。类函数宏的定义中，用圆括号括起一个或多个参数，随后这些参数出现在替换部分。例如：

    #define MEAN(X,Y) (((X)+(Y))/2)
    //MEAN(X,Y) 是宏，X 和 Y 是宏的参数；(((X)+(Y))/2) 是替换主体

类函数宏有一个点需要注意：预处理器不进行计算，而只是进行字符串替换。所以有如下示例：

    //宏 SQUARE 的定义
    #define SQUARE(X) X*X
    x = 4
    Evaluating SQUARE(x+2):The result is 14.
    //预处理器只进行字符串替换，都用 字符串 x+2 替换 X
    //替换后相当于
    x+2*x+2
    //所以 SQUARE(x+2) 的值为 14

虽然可以通过使用必需的足够多的圆括号来保证宏以正确的顺序进行运算和结合，但是不能解决宏调用增量或减量运算符的运算，所以，应尽量避免在宏的参数中使用 ++x。或者说，在宏中不要使用增量或减量运算符。

####利用宏参数创建字符串：# 运算符
ANSI C 允许在字符串中包含宏参数，在类函数宏的替换部分中，`#` 符号用作一个预处理运算符，它可以把语言符号转化为字符串。例如，如果 x 是一个宏参量，那么 #x 可以把参数名转化为相应的字符串。该过程成为字符串化（stringizing），示例如下：

    /* subst.c -- 在字符串中进行替换 */
    #include <stdio.h>
    #define PSQR(x) printf("The square of " #x " is %d.\n", ((x) * (x)))

    int main (void) {
        int y = 5;

        PSQR (y);
        PSQR (2 + 4);
        return 0;
    }

    //输出如下
    The square of y is 25.
    The square of 2 + 4 is 36.


####预处理器的粘合剂：## 运算符
和 `#` 运算符一样，`##` 运算符可以用于类函数宏的替换部分。另外，`##` 还可用于类对象宏的替换部分。这个运算符把两个语言符号组成单个语言符号。

####可变宏

虽然 “可变（variadic）” 不是标准词，但它已经成为标志这种工具的词（虽然 “字符串化（stringizing）” 和 “可变” 已经添加到 C 词汇表中，但是，固定参数的函数或宏并没有被称为固定（fixadic）函数和不变（normadic）宏）。

实现思想就是宏定义中参数列表的最后一个参数为省略号（ ... ），这样，预定义宏 `__VA_ARGS__` 就可以被用在替换部分中，以表明省略号代表什么。

####宏的总结
使用宏需要注意以下几点：

1. 记住，宏的名字中不能有空格，但是在替代字符串中可以使用空格。ANSI C 允许在参数列表中使用空格。
2. 用圆括号括住每个参数，并括住宏的整体定义。这样能确保被括起来的部分在表达式中能被正确分组。
3. 用大写字母表示宏函数名。该约定不如使用大写字母表示宏常量的约定用的广泛。但是，使用大写字母可以提醒程序员注意宏可能产生的副作用。
4. 如果打算使用宏代替函数来加快程序的运行速度，那么首先应确定宏是否会引起重大差异。在程序中只使用一次的宏对程序运行时间可能不会产生明显的改善。在嵌套循环中使用宏更有助于加速程序运行。


####文件包含：#include
预处理器发现 `#include` 指令后，就会寻找后跟的文件名并把这个文件的内容包含到当前文件中。被包含文件中的文本将替换源代码文件中的 #include 指令，就像您把被包含文件中的全部内容键入到源文件中的这个特定位置一样。

`#include` 指令有两种使用形式：

    //文件名放在尖括号中
    #include <stdio.h>         /* 搜索系统目录 */
    //文件名放在双引号中
    #include "mystuff.H"       /* 搜索当前工作目录 */

    #include "/usr/biff/p.h"   /* 搜索 /usr/biff 目录 */


####使用头文件
头文件内容的最常见形式包括：

- 明显常量——例如，典型的 `stdio.h` 文件定义 EOF、NULL 和 BUFSIZE（标准 I/O 缓冲区的大小）。
- 宏函数——例如，`getchar（）` 通常被定义为 `getc（stdin）`，`getc（）` 通常被定义为较复杂的宏，而头文件 `ctype.h` 通常包含 `ctype` 函数的宏定义。
- 函数声明——例如，头文件 `string.h` 包含字符串函数系列的函数声明。在 ANSI C 中，声明采用函数原型形式。
- 结构模板定义——标准 I/O 函数使用 FILE 结构，该结构包含文件及文件相关缓冲区的信息。头文件 `stdio.h` 中存放 FILE 结构的声明。
- 类型定义——可以使用指向 FILE 的指针作为参数调用标准 I/O 函数。通常，`stdio.h` 用 `#define` 或 `typedef` 使得 FILE 代表指向 FILE 结构的指针。与之类似，`size_t` 和 `time_t` 类型也在头文件中定义。


#### #ifdef、#else 和 #endif 指令

`#ifdef` 指令说明：如果预处理器已经定义了后面的标识符，那么执行所有指令并编译 C 代码，直到下一个 `#else` 或 `#endif` 出现为止（无论 `#else` 和 `#endif` 谁先出现）。如果有 `#else` 指令，那么，在未定义标识符时会执行 `#else` 和 `#endif` 之间的所有代码。

`#ifdef`, `#else` 格式非常类似于 C 中的 if else。主要差异为预处理器不能识别标记代码块的花括号 `{ }`，因此使用 `#else`（如果需要）和 `#endif`（必须存在）来标记指令块，这些条件结构可以嵌套。

#### #ifndef 指令
类似于 `#ifdef` 指令，`#ifndef` 指令可以与 `#else`、`#endif` 指令一起使用。`#ifndef` 判断后面的标识符是否为未定义的，`#ifndef` 的反义词为 `#ifdef`。`#ifndef` 通常用来定义此前未定义的常量。

一般地，当某文件包含几个头文件，而且每个头文件都可能定义了相同的宏时，使用 `#ifndef` 可以防止对该宏重复定义。此时，第一个头文件中的定义变成有效定义，而其他头文件中的定义则被忽略。

####预定义宏
一些 C 标准指定的预定义宏：

- `__DATE__`：进行预处理的日期，“Mmm dd yyyy” 形式的字符串文字；
- `__FILE__`：代表当前源代码文件名的字符串文字；
- `__LINE__`：代表当前源代码文件名中的行号的整数常量；
- `__STDC__`：设置为 1 时，表示该实现遵循 C 标准；
- `__STDC_HOSTED__`：为本机环境设置为 1，否则设为 0；
- `__STDC_VERSION__`：为 C99 时设置为 19901L；
- `__TIME__`：源文件编译时间，格式为 “hh: mm: ss”。

C99 标准提供一个名为 `__func__` 的预定义标识符。`__func__` 展开为一个代表函数名（该函数包含该标识符）的字符串。该标识符具有函数作用域，而宏本质上具有文件作用域。因而 `__func__` 是 C 语言的预定义标识符，而非预定义宏。

#### #line 和 #error
`#line` 指令用于重置由 `__LINE__` 和 `__FILE__` 宏报告的行号和文件名。
`#error` 指令使预处理器发出一条错误消息，该消息包含指令中的文本。可能的话，编译过程应该中断。

####内联函数
内联函数（inline function）：把函数变为内联函数将建议编译器尽可能快速地调用该函数。上述建议的效果由实现来定义。

创建内联函数的方法是在函数声明中使用函数说明符 `inline`。通常，首次使用内联函数前在文件中对该函数进行定义。因此，该定义也作为函数原型。

因为内联函数没有预留给它的单独代码块，所以无法获得内联函数的地址（实际上，可以获得地址，但这样会使编译器产生非内联函数）。另外，内联函数不会在调试器中显示。

####C 和 C++ 中的 void*
C 和 C++ 对待 `void` 类型的指针是不同的。在两种语言中，都可以把一个指向任意类型的指针赋给类型 `void*`。但是，在把一个 `void*` 指针赋给一个指针或另一个类型的时候，C++ 需要一次强制类型转换。而 C 并没有这个需要。示例如下：

    //对 void* 指针 p1 强制转型
    const double * a1 = (const double *) p1;

C 中，这种强制类型转换是可选的，在 C++ 中则是必须的。因为强制类型转换在两种语言中都有作用，因此，使用它比较有意义。如果把程序转换到 C++ 中，不必留意要改变这一部分。

####诊断库
由头文件 `assert.h` 支持的诊断库是设计用于辅助调试程序的小型库。它由宏 `assert（）` 构成。该宏接受整数表达式作为参数。如果表达式值为假（非零），宏 `assert（）` 向标准错误流（stderr）写一条错误消息并调用 `abort（）` 函数以终止程序（在头文件 `stdlib.h` 中定义了 `abort（）` 函数的原型）。

`assert（）` 宏的作用为：标识出程序中某个条件应为真的关键位置，并在条件为假时用 `asset（）` 语句终止该程序。通常，`assert（）` 的参数为关系或逻辑表达式。如果 `assert（）` 终止程序，那么它首先会显示失败的判断、包含该判断的文件名和行号。

####string.h 库中的 memcpy（）和 memmove（）
可以使用 `strcpy（）` 和 `strncpy（）` 函数复制字符数组。`memcpy（）` 和 `memmove（）` 函数可以复制其他类型的数组，两个函数原型如下：

    void *memcpy (void * restrict s1, const void * restrict s2, size_t n);
    void *memmove (void *s1, const void *s2, size_t n);

两个函数均从 s2 指向的位置复制 n 字节数据到 s1 指向的位置，且均返回 s1 的值。两者间的差别由关键字 `restrict` 造成，即 `memcpy（）` 可以假定两个内存区域之间没有重叠。`memmove（）` 函数则不做这个假定，因此，复制过程类似于首先将所有字节复制到一个临时缓冲区，然后再复制到最终目的地。

如果两个区域存在重叠使用 `memcpy（）`，其行为是不可预知的，因为编译器不会禁止使用 `memcpy（）`，所以，在使用 `memcpy（）` 时，必须确保没有重叠区域。

####第 17 章 高技术局表示

####抽象数据类型（ADT）
非正式但抽象的列表定义是：它是一个能够保存项目序列并且可以对其应用任何前面的操作的数据对象。

列表类型总结：

类型属性：可保存一个项目序列；

类型操作：

- 把列表初始化为空列表；
- 确定列表是否为空；
- 确定列表是否已满；
- 确定列表中项目的个数；
- 向列表末尾添加项目；
- 遍历列表，处理列表中每个项目；
- 清空列表。

####二叉搜索树

二叉搜索树（binary search tree）是一种结合了折半搜索策略的连接结构。树中的每一个节点都包含一个项目和两个指向其他节点（称为子节点，child node）的指针。

二叉搜索树中的每一个节点本身是其后代节点的根，此节点与其后代节点构成一个子树（subtree）。

